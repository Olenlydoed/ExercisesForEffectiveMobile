USERS
| id | name   | email            | age | status  |
|----|--------|------------------|-----|---------|
| 1  | Иван   | ivan@test.com    | 25  | active  |
| 2  | Ольга  | olga@test.com    | 30  | inactive|
| 3  | Сергей | serg@test.com    | 22  | active  |
| 4  | Мария  | maria@test.com   | 35  | active  |

2.1. Напиши SQL-запрос для выборки всех активных пользователей старше 25 лет.
SELECT * 
FROM USERS
WHERE status = 'active' AND age > 25;

2.2. Как получить количество неактивных пользователей?
SELECT COUNT(*) AS inactive_user_count 
FROM USERS 
WHERE status = 'inactive';

2.3. Какой запрос покажет имена и email всех пользователей, отсортированных по возрасту по убыванию?
SELECT name, email 
FROM USERS 
ORDER BY age DESC;

2.4. Как бы ты проверил, что при удалении пользователя данные из связанных таблиц (например, orders) тоже удаляются корректно?
  Использовать каскадное удаление (ON DELETE CASCADE), если есть внешние ключи, определенные на уровне структуры базы данных. Это гарантирует, что при удалении записи из таблицы test все связанные записи в таблице orders (или других связанных таблицах) также будут удалены.
Пример создания внешнего ключа с каскадным удалением:
CREATE TABLE orders (
	order_id INTEGER PRIMARY KEY,
  user_id INTEGER,
  FOREIGN KEY (user_id) REFERENCES USERS(id) ON DELETE CASCADE
);

- После этого как добавятся данные, можно удалить пользователя:
DELETE FROM USERS WHERE id = “нужный ID пользователя”

- Затем выполнить запрос на выборку из таблицы orders по пользователю, чтобы убедиться, что связанные данные были удалены.
SELECT * FROM orders WHERE user_id = “нужный ID пользователя”


2.5. Придумай 2 бага, которые можно было бы найти, проверяя данные через SQL
2.5.1. Некорректное значение возраста:
  Если в таблице есть пользователи с возрастом ниже 0 или с нечисловыми значениями, это является ошибкой. Можно выполнить запрос для нахождения таких пользователей:
SELECT * FROM USERS WHERE age < 0 OR age IS NULL;

2.5.2. Если в системе email пользователей должны быть уникальными, то можно проверить наличие дубликатов:
SELECT email, COUNT(*) 
FROM USERS 
GROUP BY email 
HAVING COUNT(*) > 1;
